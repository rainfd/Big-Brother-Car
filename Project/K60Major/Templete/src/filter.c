#include "filter.h"


// 一,二阶互补滤波参数 对加速度计取值的权重
const float K = 0.1;//0.02;
const float K1 = 0.05; 
const float K2 = 0.2;
	
// 卡尔曼滤波参数
float Q_angle = 0.001;        // 过程噪声的协方差   一个一行两列的矩阵
float Q_gyro = 0.003;         // 过程噪声的协方差   一个一行两列的矩阵
float R_angle = 0.5;          // 测量噪声的协方差 （测量偏差)

const float dt = 0.005;             //  采样周期 5ms

float angle, angle_dot;      // Kalman
float angle_com, angle_com2;             // Complementary

float x1, x2, y1;

char  C_0 = 1;
float Q_bias, Angle_err;
float PCt_0, PCt_1, E;
float K_0, K_1, t_0, t_1;
float Pdot[4] = {0,0,0,0};
float PP[2][2] = { { 1, 0 },{ 0, 1 } };


float Kalman_Filter(float Accel,float Gyro)		
{   
	angle += (Gyro - Q_bias) * dt;              // 先验估计
	Pdot[0] = Q_angle - PP[0][1] - PP[1][0];    // Pk 先验估计误差协方差的微分

	Pdot[1] = -PP[1][1];
	Pdot[2] = -PP[1][1];
	Pdot[3] = Q_gyro;
	PP[0][0] += Pdot[0] * dt;                   // Pk 先验估计误差协方差微分的积分
	PP[0][1] += Pdot[1] * dt;                   // 先验估计误差协方差
	PP[1][0] += Pdot[2] * dt;
	PP[1][1] += Pdot[3] * dt;
		
	Angle_err = Accel - angle;	                // Zk 先验估计
	
	PCt_0 = C_0 * PP[0][0];
	PCt_1 = C_0 * PP[1][0];
	
	E = R_angle + C_0 * PCt_0;
	
	K_0 = PCt_0 / E;
	K_1 = PCt_1 / E;
	
	t_0 = PCt_0;
	t_1 = C_0 * PP[0][1];

	PP[0][0] -= K_0 * t_0;		                // 后验估计误差协方差
	PP[0][1] -= K_0 * t_1;
	PP[1][0] -= K_1 * t_0;
	PP[1][1] -= K_1 * t_1;
		
	angle += K_0 * Angle_err;	                // 后验估计
	Q_bias += K_1 * Angle_err;	                // 后验估计
	angle_dot = Gyro - Q_bias;	                // 输出值(后验估计)的微分=角速度
    
    return angle;
}

// 一阶互补滤波
float Complementary_Filter(float angle_m, float gyro_m)
{
    
    angle_com = (angle_com + gyro_m * dt) * (1 - K) + K * angle_m;
    
    return angle_com;
}

// 二阶互补滤波
float Complementary_Filter2(float angle_m, float gyro_m)
{   
    x1 = (angle_m - angle_com2) * (1 - K2) * (1 - K2);
    y1 += x1 * dt;
    x2 = y1 + 2 * (1 - K2) * (angle_m - angle_com2) + gyro_m;
    angle_com2 = angle_com + x2 * dt;
    
    return angle_com2;
}
/*
float Complementary_Filter(float angle_m, float gyro_m)
{
    
    angle_com = (angle_com + gyro_m * 0.005) * (1 - K) + K * angle_m;
    
    return angle_com;
}
*/